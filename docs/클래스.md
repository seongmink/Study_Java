# 클래스

## 객체 지향 프로그래밍

부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 객체 지향 프로그래밍(OOP : Object Oriented Programming)이라고 한다.

- ### 객체란?

  객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신ㅇ의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다. 객체는 속성과 동작으로 구성되어 있다. 자바는 이 속성과 동작들을 각각 필드(filed)와 메소드(method)라고 부른다.

  현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링(Object Modeling)이라고 한다. 객체 모델링은 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정이라고 볼 수 있다.

- ### 객체 간의 관계

  객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다. 이 관계에는 집합 관계, 사용 관계, 상속 관계가 있다.

  - **집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당한다.** 예를 들어 자동차는 엔진, 타이어, 핸들 등으로 구성되므로 자동차와 이 부품들은 집합의 관계라고 볼 수 있다.
  - **사용 관계는 객체간의 상호작용**을 말한다. 객체는 다른 메소드를 호출하여 원하는 결과를 얻어낸다. 예를 들어 사람은 자동차를 사용하므로 사람과 자동차는 사용의 관계라고 볼 수 있다. 사람은 자동차를 사용할 때 달린다, 멈춘다 등의 메소드를 호출한다.
  - **상속 관계는 상위(부모) 객체를 기반으로 하위(자식) 객체에 생성하는 관계**를 말한다. 일반적으로 상위 객체는 종류를 의미하고, 하위 객체는 구체적인 사물에 해당한다. 예를 들어 "자동차는 기계의 종류이다" 에서 기계(상위)와 자동차(하위)는 상속 관계에 있다고 볼 수 있다.

- ### 객체 지향 프로그래밍의 특징

  객체 지향 프로그램의 특징으로는 캡슐화, 상속, 다형성을 들 수 있다. 

  #### 캡슐화(Encapsulation)

  캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다. 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다. 

  자바는 캡슐화된 멤버를 노출 시킬 것인지, 숨길 것인지를 결정하기 위해 접근 제한자(Access Modifier)를 사용한다. 접근 제한자는 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호한다.

  #### 상속(Inheritance)

  부모 역할의 상위 객체와 자식 역할의 하위 객체가 있다. 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 해준다.

  상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여준다. 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화시켜주기도 한다.

  #### 다형성(Polymorphism)

  다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다. 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.

  다형성의 효과로는 객체는 부품화가 가능하다. 예를 들어 자동차를 설계할 때 타이어 인터페이스 타입을 적용했다면 이 인터페이스를 구현한 실제 타이어들은 어떤 것이든 사관없이 장착(대입)이 가능하다.

## 객체와 클래스

메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당하는 객체를 만드는 작업이 필요하다. 자바에서는 설계도가 바로 **클래스**(class)이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 클래스로부터 만들어진 객체를 해당 클래스의 **인스턴스**(instance)라고 한다. 그리고 클래스로부터 객체를 만드는 과정을 **인스턴스화**라고한다.

객체 지향 프로그래밍 개발은 세 가지 단계가 있다. 첫 번째 단계는 클래스를 설계해야 한다. 두 번째 단계는 설계된 클래스를 가지고 사용할 객체를 생성해야 한다. 마지막은 생성된 객체를 이용하는 것이다.

## 클래스 선언

클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 자바의 식별자 작성 규칙에 따라서 만들어야 한다.

| 번호 | 작성 규칙                                 | 예                           |
| ---- | ----------------------------------------- | ---------------------------- |
| 1    | 하나 이상의 문자로 이루어져야 한다.       | Car, SportsCar               |
| 2    | 첫 번째 글자는 숫자가 올 수 없다.         | Car, 3Car(x)                 |
| 3    | '$', '_' 외의 특수 문자는 사용할 수 없다. | $Car, _Car, @Car(x), #Car(x) |
| 4    | 자바 키워드는 사용할 수 없다.             | int(x), for(x)               |

클래스 이름은 한글이든 영어든 상관없지만, 한글로 클래스 이름을 만드는 경우는 거의 없다. 자바는 영어 대소문자를 다른 문자로 취급하기 때문에 클래스 이름도 영어 대소문자를 구분한다. 관례적으로 클래스 이름이 단일 단어라면 첫 자를 대문자로 하고, 나머지는 소문자로 작성한다. 만약 서로 다른 단어가 혼합된 이름을 상용한다면 각 단어의 첫 머리 글자는 대문자로 작성하는 것이 관례이다.

```
Calculator, Car, Member, ChatClient, ChatServer, Web_Server
```

## 객체 생성과 클래스 변수

클래스로부터 객체를 생성하는 방법은 다음과 같이 new 연산자를 사용하면 된다. new는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.

new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 그리고 객체 주소를 리턴하도록 되어 있다. 이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.

## 클래스의 구성 멤버

클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(Method)가 있다. 이 구성 멤버들은 생략되거나 복수 개가 작성될 수 있다.

```java
public class ClassName {
	// 필드(객체의 데이터가 저장되는 곳)
    int fieldName;
    
    // 생성자(객체 생성 시 초기화 역할 담당)
    ClassName() { ... }
    
    // 메소드(객체의 동작에 해당하는 실행 블록)
    void methodDName() { ... }
}
```

- ### 필드

  필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다. 선언 형태는 변수(variable)와 비슷하지만, 필드를 변수라고 부르지 않는다. 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다. 하지만 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.

- ### 생성자

  생성자는 new 연산자로 호출되는 특별한 중괄호 {} 블록이다. 생성자의 역할은 객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다. 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없다.

- ### 메소드

  메소드는 객체 동작에 해당하는 중괄호 {} 블록을 말한다. 중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다. 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 메소드는 객체 간의 데이터 전달의 수단으로 사용된다. 외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수 도있다.

## 필드

필드(Field)는 객체의 고유한 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳이다.

- ### 필드 선언

  필드 선언은 클래스 중괄호 {} 블록 어디서든 존재할 수 있다. 생성자 선언과 메소드 선언의 앞과 뒤 어떤 곳에서도 필드 선언이 가능하다. 하지만 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다. 생ㅇ성자의 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 된다. 

  초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정된다. 필드의 타입에 따라 초기값이 다른데, 다음 표는 필드 타입별 기본 초기값이다.

  | 분류      | 하위 분류 | 데이터 타입                                   | 초기값                                       |
  | --------- | --------- | --------------------------------------------- | -------------------------------------------- |
  | 기본 타입 | 정수 타입 | byte<br />char<br />short<br />int<br />long  | 0<br />\u0000(빈 공백)<br />0<br />0<br />0L |
  | 기본 타입 | 실수 타입 | float<br />double                             | 0.0F<br />0.0                                |
  | 기본 타입 | 논리 타입 | boolean                                       | false                                        |
  | 참조 타입 | 참조 타입 | 배열<br />클래스(String 포함)<br />인터페이스 | null<br />null<br />null                     |

- ### 필드 사용

  필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다. 클래스 내부에 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만, 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다. 그 이유는 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다.

  외부 클래스에서 필드값을 사용하려면 객체를 우선 생성해야 한다. 생성후 도트(.) 연산자를 사용해서 필드에 접근할 수 있다. 도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나, 메소드를 사용하고자 할 때 사용된다.

## 생성자

생성자(Constructor)는 new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 객체 초기화란 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것을 말한다. 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.

- ### 기본 생성자

  모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 중괄호 {} 블록 내용이 비어있는 기본 생성자(Default Constructor)를 바이트 코드에 자동 추가시킨다. 그러나 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 않는다. 명시적으로 생성자를 선언하는 이유는 객체를 다양하기 초기화하기 위해서이다.

- ### 생성자 선언

  기본 생성자 대신 생성자를 명시적으로 선언하려면 다음과 같은 형태로 작성하면 된다.

  ```
  클래스( 매개변수선언, ... ) {
  	// 객체의 초기화 코드
  }
  ```

  생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다.

- ### 필드 초기화

  클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다. 만약 다른 값으로 초기화를 하고 싶다면 두 가지 방법이 있다. 하나는 필드를 선언할 때 초기값을 주는 방법이고, 또 다른 하나는 생성자에서 초기값을 주는 방법이다. 필드를 선언할 때 초기값을 주게 되면 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게 된다. 물론 객체 생성 후 변경할 수 있지만, 객체 생성 시점에는 필드의 값이 모두 같다.

  생성자의 매개변수는 관례적으로 필드와 동일한 이름을 같도록 한다. 이 경우 필드와 매개 변수 일므이 동이랗기 때문에 생성자 내부에서 해당 필드에 접근할 수 없다. 왜냐하면 동일한 이름의 매개 변수가 사용 우선순위가 높기 때문이다. 해결 방법은 필드 앞에 "this."를 붙이면 된다.

  ```java
  public Korean(String name, String ssn) {
  	this.name = name;
      this.ssn = ssn;
  }
  ```

- ### 생성자 오버로딩(Overloading)

  외부에서 제공되는 다양한 데이터들을 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있다. 자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공한다. 생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.

  ```java
  public class Car {
  	Car() { ... }
      Car(String model) { ... }
      Car(String model, String color) { ... }
      Car(String model, String color, int maxSpeed) { ... }
  }
  ```

  생성자 오보러딩 시 주의할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이라고 볼 수 없다. 다음과 같은 경우다.

  ```java
  Car(String model, String color) { ... }
  Car(String color, String model) { ... } // 오버로딩이 아님
  ```

- ### 다른 생성자 호출(this())

  생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다. 매개 변수의 수만 달리 하고 필드 초기화 내용이 비슷한 생성자에서 이러한 현상을 많이 볼 수 있다. 이 경우에는 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.

  ```
  클래스 ( [매개변수선언, ...]) {
  	this( 매개변수, ..., 값, ...); // 클래스의 다른 생성자 호출
  	실행문;
  }
  ```

  다음과 같이 중복을 제거할 수 있다.

  ```java
  Car(String model) {
      this(moddel, "은색", 250); // 맨 밑 생성자 호출
  }
  Car(String model, String color) {
      this(model, color, 250); // 맨 밑 생성자 호출
  }
  Car(String model, Stirng color, int maxSpeed) {
      this.model = model;
      this.color = color;
      this.maxSpeed = maxSpeed;
  }
  ```

## 메소드

메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.

- ### 메소드 선언

  메소드 선언은 선언부(리턴타입, 메소드이름, 매개변수선언)와 실행 블록으로 구성된다. 메소드 선언부를 메소드 시그니처(signature)라고도 한다.

  #### 리턴 타입

  리턴 타입은 메소드가 실행 후 리턴하는 값의 타입을 말한다. 메소드가 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴값이 있어야 한다.

  #### 메소드 이름

  메소드 이름은 자바 식별자 규칙에 맞게 작성하면 되는데, 다음 사항에 주의하면 된다.

  - 숫자로 시작하면 안 되고, $와 _를 제외한 특수 문자를 사용하지 말아야 한다.
  - 관례적으로 메소드명은 소문자로 작성한다.
  - 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫머리 글자는 대문자로 작성한다.

  #### 매개 변수 선언

  매개 변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다. 매개 변수도 필요한 경우가 있고 필요 없는 경우가 있다.

  #### 매개 변수의 수를 모를 경우

  메소드의 매개 변수는 개수가 이미 정해져 있는 것이 일반적이지만, 경우에 따라서는 메소드를 선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다. 예를 들어 여러 개의 수를 모두 합산하는 메소드를 선언해야 한다면, 몇 개의 매개 변수가 입력될 지 알 수 없기 때문에 매개 변수의 개수를 결정할 수 없을 것이다. 해결책은 다음과 같이 매개 변수를 배열 타입으로 선언하는 것이다.

  ```java
  int sum1(int[] values) { ... }
  ```

  sum1() 메소드를 호출할 때 배열을 넘겨줌으로써 배열의 항목 값들을 모두 전달할 수 있다. 배열의 항목 수는 호출할 때 결정된다.

  ```java
  int[] values = {1, 2, 3};
  int result = sum1(values);
  int result2 = sum1(new int[] {1, 2, 3, 4, 5});
  ```

  매개 변수를 배열 타입으로 선언하면, 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다. 그래서 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다. 다음과 같이 sum2() 메소드의 매개 변수를 "..."를 사용해서 선언하게 되면, 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.

  ```java
  int sum2(int ... values) { ... }
  ```

  "..."로 선언된 매개 변수의 값은 다음과 같이 메소드 호출 시 리스트로 나열해주면 된다.

  ```java
  int result = sum2(1, 2, 3);
  int result2 = sum2(1, 2, 3, 4, 5);
  ```

  "..."로 선언된 매개 변수는 배열 타입이므로 이전과 같이 배열을 직접 매개값으로 사용해도 된다.

- ### 리턴(return)문

  #### 리턴값이 있는 메소드

  메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 한다. 만약 return문이 없다면 컴파일 오류가 발생한다. return문이 실행되면 메소드는 즉시 종료된다.

  ```java
  return 리턴값;
  ```

  #### 리턴값이 없는 메소드(void)

  void로 선언된 리턴값이 없는 메소드에서도 return 문을 사용할 수 있다.

  ```java
  return;
  ```

- ### 메소드 호출

  메소드는 클래스 내·외부의 호출에 의해 실행된다. 클래스 내부의 다른 메소드에서 호출할 경우에는 단순한 메소드 이름으로 호출하면 되지만, 클래스 외부에서 호출할 경우에는 우선 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야 한다. 그 이유는 객체가 존재해야 메소드도 존재하기 때문이다.

  #### 객체 내부에서 호출

  클래스 내부에서 다른 메소드를 호출할 경우에는 다음과 같은 형태로 작성하면 된다. 메소드가 매개 변수를 가지고 있을 때에는 매개 변수의 타입과 수에 맞게 매개값을 제공한다.

  ```
  메소드( 매개값, ... );
  ```

  ##### ClassName 클래스

  ```java
  public class ClassName {
      int method1(int x, int y) {
          return x + y;
      }
      
      int method2() {
          int result1 = method1(10, 20); // 30
          double result2 = method1(10, 20); // 30.0
      }
  }
  ```

  #### 객체 외부에서 호출

  외부 클래스에서 메소드를 호출하려면 우선 다음과 같이 클래스로부터 객체를 생성해야 한다. 메소드는 객체에 소속된 멤버이므로 객체가 존재하지 않으면 메소드도 존재하지 않기 때문이다.

  ```java
  클래스 참조변수 = new 클래스(매개값, ...);
  참조변수.메소드(매개값, ...); // 리턴값이 없거나, 있어도 리턴값을 받지 않을 경우
  타입 변수 = 참조변수.메소드(매개값, ...); // 리턴값이 있고, 리턴값을 받고 싶은 경우
  ```

  ##### CarExample 클래스

  ```java
  public class CarExample {
      public static void main(String[] args) {
          Car myCar = new Car();
          myCar.keyTurnOn();
          myCar.run();
          int speed = myCar.getSpeed();
      }
  }
  ```

- ### 메소드 오버로딩

  클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩(overloading)이라고 한다. 오버로딩의 사전적 의미는 많이 싣는 것을 뜻한다. 하나의 메소드 이름으로 여러 기능을 담는다 하여 붙여진 이름이라 생각할 수 있다. 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다.

## 인스턴스 멤버와 this

인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.

객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 맴베어 접근하기 위해 this를 사용할 수 있다. this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할때 사용된다.

## 정적 멤버와 static

정적(static)은 '고정된'이란 의미를 가지고 있다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이들은 각각 정적 필드, 정적 메소드라고 부른다. 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.

- ### 정적 멤버 선언

  정적 필드와 정적 메소드를 선언하는 방법은 필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면 된다.

  ```java
  public class 클래스 {
  	// 정적 필드
      static 타입 필드 [= 초기값];
      
      // 정적 메소드
      static 리턴 타입 메소드(매개변수선언, ...) { ... }
  }
  ```

  정적 필드와 정적 메소드는 클래승에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스 로딩이 바로 끝나면 바로 사용할 수 있다.

  필드를 선언할 때 인스턴스 필드로 선언할 것인가, 아니면 정적 필드로 선언할 것인가의 판단 기준은 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고, 객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적 필드로 선언하는 것이 좋다. 

- ### 정적 멤버 사용

  클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 도트(.) 연산자로 접근한다. (인스턴스 생성 X)

  예를 들면 Calculator 클래스가 다음과 같이 작성되었다면,

  ```java
  public class Calculator {
      static double pi = 3.14159;
      static int plus(int x, int y) { ... }
      static int minus(int x, int y) { ... }
  }
  ```

  정적 필드 pi와 정적 메소드 plus(), minus()는 다음과 같이 사용할 수 있다.

  ```java
  double result1 = 10 * 10 * Calculator.pi;
  int result2 = Calculator.plus(10, 5);
  int result3 = Calculator.minus(10, 5);
  ```

  정적 필드와 정적 메소드는 원칙적으로 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근이 가능하다. 하지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다.

- ### 정적 초기화 블록

  정적 필드는 다음과 같이 필드 선언과 동시에 초기값을 주는 것이 보통이다.

  ```java
  static double pi = 3.14159;
  ```

  정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없다. 그렇다면 정적 필드를 위한 초기화 작업은 어디서 해야 할까? 자바는 정적 필드의 복잡한 초기화 작업을 위해서 정적 블록(static block)을 제공한다.

  ```java
  static {
  	....
  }
  ```

  정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다. 정적 블록은 클래스 내부에 여러개가 선언되어도 상관없다. 클래스가 메모리로 로딩될 때 선언된 순서대로 실행된다.

- ### 정적 메소드와 블록 선언시 주의할 점

  정적 메소드와 정적 블록을 선언할 때 주의할 점은 객체가 없어도 실행된다는 특징 때문에, 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 객체 자신의 참조인 this 키워드도 사용이 불가능하다.

  정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 다음과 같이 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

  ```java
  static void Method3() {
      ClassName obj = new ClassName();
      obj.field = 10;
      obj.method1();
  }
  ```

- ### 싱글톤(Singleton)

  단 하나의 객체만 만들도록 보장해야하는 경우가 있다. 단 하나만 생성된다고 해서 이 객체를 싱글톤(Singleton)이라고 한다. 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다. 생성자를 호출한 만큼 객체가 생성되기 때문이다. 

  - 생성자를 외부에서 호출할 수 없도록 하려면 생성자 앞에 private 접근 제한자를 붙여주면 된다. 
  - 그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다. 참고로 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다. 
  - 정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다. 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

  ```java
  public class 클래스 {
      // 정적 필드
      private static 클래스 singleton = new 클래스();
      
      // 생성자
      private 클래스() {}
      
      // 정적 메소드
      static 클래스 getInstance() {
          return singleton;
      }
  }
  ```

  외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출하는 방법이다. getInstance() 메소드는 단 하나의 객체만 리턴하기 때문에 아래 코드에서 변수1과 변수2는 동일한 객체를 참조한다.

  ```
  클래스 변수1 = 클래스.getInstance();
  클래스 변수2 = 클래스.getInstance();
  ```

  ##### Singleton 클래스

  ```java
  public class Singleton {
      private static Singleton singleton = new Singleton();
      
      private Singleton() {}
      
      static Singleton getInstance() {
          return singleton;
      }
  }
  ```

  ##### SingletonExample 클래스

  ```java
  public class SingletonExample {
      public static void main(String[] args) {
          /*
          Singleton obj1 = new Singleton(); // 컴파일 에러
          Singleton obj2 = new Singleton(); // 컴파일 에러
          */
          
          
      }
  }
  ```

  

## final 필드와 상수



## 패키지



## 접근 제한자



## Getter와 Setter 메소드



## 어노테이션